unit TestStatistics;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
   TestFramework, Generics.Collections, System.SysUtils, Math, uStatistics;

type
   // Test methods for class IStatistics

   TestIStatistics = class(TTestCase)
   strict private
      FIStatistics: IStatistics;
   public
      procedure SetUp; override;
      procedure TearDown; override;
   published
      procedure TestSetDataFromString;
      procedure TestGetMean;
      procedure TestGetMode;
      procedure TestGetMedian;
      procedure TestGetVariance;
      procedure TestGetStandardDeviation;
      procedure TestGetRange;
      procedure TestGetMinimum;
      procedure TestGetMaximum;
      procedure TestGetSum;
   end;

implementation

procedure TestIStatistics.SetUp;
begin
   FIStatistics := TStatistics.Create;
end;

procedure TestIStatistics.TearDown;
begin
   FIStatistics := nil;
end;

procedure TestIStatistics.TestSetDataFromString;
var
   ReturnValue: TValidationResult;
   Value: string;
begin
   // Teste com string válida contendo números inteiros separados por vírgula
   Value := '1, 2, 3, 4, 5, -1, -2, -3, 0';
   ReturnValue := FIStatistics.SetDataFromString(Value);
   CheckEquals(Ord(vrValid), Ord(ReturnValue),
     'SetDataFromString falhou ao processar uma string válida.');

   // Teste com string inválida contendo caracteres não numéricos
   Value := '1. 2.5, 3, A, Teste, 0, -1, C';
   ReturnValue := FIStatistics.SetDataFromString(Value);
   CheckEquals(Ord(vrInvalid), Ord(ReturnValue),
     'SetDataFromString falhou ao processar uma string com caracteres inválidos.');

   // Teste com string vazia
   Value := '';
   ReturnValue := FIStatistics.SetDataFromString(Value);
   CheckEquals(Ord(vrEmpty), Ord(ReturnValue),
     'SetDataFromString falhou ao processar uma string vazia.');
end;

procedure TestIStatistics.TestGetMean;
var
   ReturnValue: Double;
   AData: array of Double;
begin
   // Teste com valores positivos
   AData := [1, 2, 3, 4];
   ReturnValue := FIStatistics.GetMean(AData);
   CheckEquals(2.5, ReturnValue,
     'GetMean não foi calculada corretamente para um array de números positivos.');

   // Teste com valores negativos
   AData := [-1, -2, -3, -4, -5];
   ReturnValue := FIStatistics.GetMean(AData);
   CheckEquals(-3, ReturnValue,
     'GetMean não foi calculada corretamente para um array de números negativos.');

   // Teste com array contendo apenas zero
   AData := [0];
   ReturnValue := FIStatistics.GetMean(AData);
   CheckEquals(0, ReturnValue,
     'GetMean não foi calculada corretamente para um array contendo apenas zero.');
end;

procedure TestIStatistics.TestGetMode;
var
   ReturnValue: Double;
   AData: array of Double;
begin
   // Teste com empate de contagem = 1
   AData := [0, 1, 2, 3];
   ReturnValue := FIStatistics.GetMode(AData);
   CheckEquals(3, ReturnValue,
     'GetMode não identificou corretamente o elemento único de maior frequência.');

   // Teste com empate de contagem > 1
   AData := [0, 1, 1, 2, 3, 2, 3];
   ReturnValue := FIStatistics.GetMode(AData);
   CheckEquals(3, ReturnValue,
     'GetMode não identificou corretamente o último elemento de maior frequência.');

   // Teste sem empate (valores únicos)
   AData := [0, 1, 2, 3, 3, 4, 5];
   ReturnValue := FIStatistics.GetMode(AData);
   CheckEquals(3, ReturnValue,
     'GetMode não identificou corretamente o elemento de maior frequência.');

   // Teste com array contendo apenas zero
   AData := [0];
   ReturnValue := FIStatistics.GetMode(AData);
   CheckEquals(0, ReturnValue,
     'GetMode não identificou corretamente um array contendo apenas zero.');
end;

procedure TestIStatistics.TestGetMedian;
var
   ReturnValue: Double;
   AData: array of Double;
begin
   // Teste com número de elementos par
   AData := [1, 2, 3, 4];
   ReturnValue := FIStatistics.GetMedian(AData);
   CheckEquals(2.5, ReturnValue,
     'GetMedian não calculou corretamente para um array com número par de elementos.');

   // Teste com número de elementos ímpar
   AData := [1, 2, 3, 4, 5];
   ReturnValue := FIStatistics.GetMedian(AData);
   CheckEquals(3, ReturnValue,
     'GetMedian não calculou corretamente para um array com número ímpar de elementos.');

   // Teste com array contendo apenas zero
   AData := [0];
   ReturnValue := FIStatistics.GetMedian(AData);
   CheckEquals(0, ReturnValue,
     'GetMedian não calculou corretamente para um array contendo apenas zero.');
end;

procedure TestIStatistics.TestGetVariance;
var
   ReturnValue: Double;
   AData: array of Double;
begin
   // Teste com valores positivos
   AData := [1, 2, 3, 4, 5, 6];
   ReturnValue := FIStatistics.GetVariance(AData);
   CheckEquals(2.916, ReturnValue, 0.001,
     'GetVariance não calculou corretamente a variância para um array com valores positivos.');

   // Teste com valores negativos
   AData := [-1, -2, -3, -4, -5];
   ReturnValue := FIStatistics.GetVariance(AData);
   CheckEquals(2.000, ReturnValue, 0.001,
     'GetVariance não calculou corretamente a variância para um array com valores negativos.');

   // Teste com array contendo apenas zero
   AData := [0];
   ReturnValue := FIStatistics.GetVariance(AData);
   CheckEquals(0.000, ReturnValue, 0.001,
     'GetVariance não calculou corretamente a variância para um array contendo apenas zero.');

   // Teste com array contendo apenas um elemento
   AData := [100];
   ReturnValue := FIStatistics.GetVariance(AData);
   CheckEquals(0.000, ReturnValue, 0.001,
     'GetVariance não calculou corretamente a variância para um array contendo apenas um elemento.');
end;

procedure TestIStatistics.TestGetStandardDeviation;
var
   ReturnValue: Double;
   AData: array of Double;
begin
   // Teste com valores positivos
   AData := [1, 2, 3, 4, 5, 6];
   ReturnValue := FIStatistics.GetStandardDeviation(AData);
   CheckEquals(1.707, ReturnValue, 0.001,
     'GetStandardDeviation não calculou corretamente o desvio para um array com valores positivos.');

   // Teste com valores negativos
   AData := [-1, -2, -3, -4, -5];
   ReturnValue := FIStatistics.GetStandardDeviation(AData);
   CheckEquals(1.414, ReturnValue, 0.001,
     'GetStandardDeviation não calculou corretamente o desvio para um array com valores negativos.');

   // Teste com array contendo apenas zero
   AData := [0];
   ReturnValue := FIStatistics.GetStandardDeviation(AData);
   CheckEquals(0.000, ReturnValue, 0.001,
     'GetStandardDeviation não calculou corretamente o desvio para um array contendo apenas zero.');

   // Teste com array contendo apenas um elemento
   AData := [-100];
   ReturnValue := FIStatistics.GetStandardDeviation(AData);
   CheckEquals(0.000, ReturnValue, 0.001,
     'GetStandardDeviation não calculou corretamente o desvio para um array contendo apenas um elemento.');
end;

procedure TestIStatistics.TestGetRange;
var
   ReturnValue: Double;
   AData: array of Double;
begin
   // Teste com valores positivos
   AData := [6, 1, 3];
   ReturnValue := FIStatistics.GetRange(AData);
   CheckEquals(5, ReturnValue,
     'GetRange não calculou corretamente a amplitude para um array com valores positivos.');

   // Teste com valores negativos
   AData := [-5, -6, -10];
   ReturnValue := FIStatistics.GetRange(AData);
   CheckEquals(5, ReturnValue,
     'GetRange não calculou corretamente a amplitude para um array com valores negativos.');

   // Teste com menor elemento igual a 0
   AData := [0, 1];
   ReturnValue := FIStatistics.GetRange(AData);
   CheckEquals(1, ReturnValue,
     'GetRange não calculou corretamente a amplitude para um array com menor elemento igual a 0.');

   // Teste com array contendo apenas zero
   AData := [0];
   ReturnValue := FIStatistics.GetRange(AData);
   CheckEquals(0, ReturnValue,
     'GetRange não calculou corretamente a amplitude para um array contendo apenas zero.');

   // Teste com array contendo apenas um elemento
   AData := [100];
   ReturnValue := FIStatistics.GetRange(AData);
   CheckEquals(0, ReturnValue,
     'GetRange não calculou corretamente a amplitude para um array contendo apenas um elemento.');
end;

procedure TestIStatistics.TestGetMinimum;
var
   ReturnValue: Double;
   AData: array of Double;
begin
   // Teste com valores positivos
   AData := [3, 2, 1];
   ReturnValue := FIStatistics.GetMinimum(AData);
   CheckEquals(1, ReturnValue,
     'GetMinimum não calculou corretamente o menor valor para um array com valores positivos.');

   // Teste com valores negativos
   AData := [-5, -6, -10];
   ReturnValue := FIStatistics.GetMinimum(AData);
   CheckEquals(-10, ReturnValue,
     'GetMinimum não calculou corretamente o menor valor para um array com valores negativos.');

   // Teste com array contendo apenas zero
   AData := [0];
   ReturnValue := FIStatistics.GetMinimum(AData);
   CheckEquals(0, ReturnValue,
     'GetMinimum não calculou corretamente o menor valor para um array contendo apenas zero.');

   // Teste com array contendo apenas um elemento
   AData := [1];
   ReturnValue := FIStatistics.GetMinimum(AData);
   CheckEquals(1, ReturnValue,
     'GetMinimum não calculou corretamente o menor valor para um array contendo apenas um elemento.');
end;

procedure TestIStatistics.TestGetMaximum;
var
   ReturnValue: Double;
   AData: array of Double;
begin
   // Teste com valores positivos
   AData := [3, 2, 1];
   ReturnValue := FIStatistics.GetMaximum(AData);
   CheckEquals(3, ReturnValue,
     'GetMaximum não calculou corretamente o maior valor para um array com valores positivos.');

   // Teste com valores negativos
   AData := [-5, -6, -10];
   ReturnValue := FIStatistics.GetMaximum(AData);
   CheckEquals(-5, ReturnValue,
     'GetMaximum não calculou corretamente o maior valor para um array com valores negativos.');

   // Teste com array contendo apenas zero
   AData := [0];
   ReturnValue := FIStatistics.GetMaximum(AData);
   CheckEquals(0, ReturnValue,
     'GetMaximum não calculou corretamente o maior valor para um array contendo apenas zero.');

   // Teste com array contendo apenas um elemento
   AData := [1];
   ReturnValue := FIStatistics.GetMaximum(AData);
   CheckEquals(1, ReturnValue,
     'GetMaximum não calculou corretamente o maior valor para um array contendo apenas um elemento.');
end;

procedure TestIStatistics.TestGetSum;
var
   ReturnValue: Double;
   AData: array of Double;
begin
   // Teste com valores positivos e negativos
   AData := [3, 2, 1, 0, -1, -2, -3];
   ReturnValue := FIStatistics.GetSum(AData);
   CheckEquals(0, ReturnValue,
     'GetSum não calculou corretamente a soma para um array com valores positivos e negativos.');

   // Teste com valores positivos
   AData := [3, 2, 1];
   ReturnValue := FIStatistics.GetSum(AData);
   CheckEquals(6, ReturnValue,
     'GetSum não calculou corretamente a soma para um array com valores positivos.');

   // Teste com valores negativos
   AData := [-3, -2, -1];
   ReturnValue := FIStatistics.GetSum(AData);
   CheckEquals(-6, ReturnValue,
     'GetSum não calculou corretamente a soma para um array com valores negativos.');

   // Teste com array contendo apenas zero
   AData := [0];
   ReturnValue := FIStatistics.GetSum(AData);
   CheckEquals(0, ReturnValue,
     'GetSum não calculou corretamente a soma para um array contendo apenas zero.');

   // Teste com array contendo apenas um elemento
   AData := [1];
   ReturnValue := FIStatistics.GetSum(AData);
   CheckEquals(1, ReturnValue,
     'GetSum não calculou corretamente a soma para um array contendo apenas um elemento.');
end;

initialization

   RegisterTest(TestIStatistics.Suite);

end.
